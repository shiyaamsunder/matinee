# Development Log:

## 17/01/2026
1. Setup server project with springboot
    - chose springboot since thats what I want to skill up
2. setup flyway for database migration
    - to have have db migration and history
3. Write initial ddl scripts for the tables
    -  chose uuid for ids and to generate them in db level.
    -  will prevent duplicates if you have multiple client instances, for example load balanced web servers

Questions

1. Can we use the interval postgres type for the show timings?
2. How to account for seat numbers and occupied capacity of a given screen.?


## 18/01/2026

TODO for previous day
- [x] need to check how to map postgres uuid type to jpa
- [x] Add proper comments in db schema
- [x] add on delete on update for foreign keys
- [ ] evaluate whether a trigger is needed for modified_date => Task for another day
- [ ] Generate ER diagram whenever there is a schema change => Task for another day

### Thoughts on Auditing

Automatically updating the timestamps as the data gets updated. I wanted to make use of this so that it is possible to track when an entry has been modified. This is but one aspect of the auditing mechanism. Hence the dilemma on whether to use triggers or jpa annotations for handling timestamp updates seems redudant to me.
I'm seeing polarizing views and takes on where to have the "update" logic for a given entry. Some say having it on db side helps if there are multiple clients trying to update then db will be the source of truth. Others argue that client should always be responsible for updating the timestamp.

Auditing is a planned feature for this backend project. And I'm currently evaluating which framework to use. My current considerations are javers and envers.
Both has its [pros and cons](https://javers.org/blog/2017/12/javers-vs-envers-comparision.html)
I will mostly use javers since it's a relatively new one compared to envers and is independent of the db type.
I will come back to auditing once I'm done with defining the Entities in the codebase.

### Following Best Practices using JPA

Currently going through this [blog](https://protsenko.dev/spring-data-jpa-best-practices-entity-design-guide/). Still
trying to understand what each annotation does in jpa. Like difference between @Entity and @Table or how to do joins using
JPA.

## 31/01/2026

Man!!

It's been a while now. Went for a short trip. Had some time to reflect. Got occupied in work immediately after. Now I'm resuming this project after 12days. So far I have a basic table structure to start from. As the project grows it will evolve.

Pending Todos

- [x] evaluate whether a trigger is needed for modified_date: Used hibernates annotations
- ~~[ ] Generate ER diagram whenever there is a schema change~~ -> Not going to do this for now.


After like 4 hours of back and forth coding, I wrote some rough structure for the user api.
As of now exposed a `addNewUser` api endpoint that saves a new user in db with automatic timestamp generation.
Not sure if the timestamp is being generated by the db or the annotation (need to verify this.)

Added related Domains, DTO, Repositories

Added a Converter class for `MatineeUser`

Updated dependencies to use non-vulnerable versions.

Added `bruno` for api testing, 

TODO:

- [x] Update readme.

## 01/02/2026

So a couple of things to unpack. 

### Timestamps 
Verified whether the `@CreationTimestamp` is working properly. I removed the default `now()` from the table schema and
used the `@CreationTimestamp` from JPA to generate the timestamp before persisting. I was able to see the timestamp 
getting populated in DB with a quick endpoint that I hacked together (more info [below](devlog.md#thoughts-on-architecture-and-code-structure)).
So right now JPA is handling the timestamp creation instead of postgres. If I want, in future I can handle how the timestamp
gets created before persisting it. Now that's out of the way.


### Lombok? Black magic?
Started using lombok annotations for reducing the boilerplate code. I have worked with it before and never faced any issue,
until today. I was switching between IDE's and finally settled with Intellij yesterday (I was using zed previously) since
it has more sensible defaults for java development. And last night everything was working fine. Today the code didn't even
compile for some reason. I was like `wtf!!!`. Then after like hours of googling and chatgpteeing (yes, I use that word regularly)
found that in order for lombok to work when you do `mvn clean install` you need to define the annotation processer path in
maven compiler plugin configuration.

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>${java.version}</source>
        <target>${java.version}</target>
        <annotationProcessorPaths>
            <path>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
            </path>
        </annotationProcessorPaths>
    </configuration>
</plugin>
```

This will tell maven to process the lombok annotations whenever you manually compile instead of running the project from Intellij

And apparently IntelliJ will do this, if you check the "Enable lombok processing" popup, which I did click. 

New day! new learning!

### Thoughts on Architecture and Code Structure

Whenever I see an enterprise project, I always wonder why the project maintainers choose a specific way to write and maintain code.

In software development, I feel like there are two schools of thought. 
1. Write maintainable code from inception. 
2. Make it work first, ship fast, refactor later.

And every time when I code, I try to follow the first approach but somehow end up falling into the second approach.

Same thing happened here.

Initially my plan was as follows

- Setup proper DB schema
- Then the domain layer for the entire schema in java
- Service Layer
- Controller Layer

I was trying to do a bottom up approach for every entity that I had laid out. It was all going fine, first wrote all the 
entities and repository layer with proper annotations, but the thing is, I had no way of testing the JPA entities,
especially the timestamp generation which I mentioned in one of the previous section.So I had to hastily write a 
controller, dto, entity to dto, and dto to entity converters and a bare minimum service layer with no validations. 

Not a satisfying experience.

> *One of the reason why yesterday's devlog feels very crude with no details :(*

Maybe I should have written tests? or used debug mode during runtime to test the timestamp generation?
Or, Maybe I should have put that thing in the back seat and worried about it for another day? Not sure.

For now, all I need to do is, keep on moving.

> *Keep on keeping on!*

### Learnings

- `@MappedSuperclass` allows to mark a base class that can provide "persistent" fields to its subclasses but does not 
make the class itself an entity. Perfect for reusability. Here I used it for creating a `BaseEntity` which contains
a `created_date` and `modified_date`. And all my entities that inherit this super class will get the timestamp fields.
- `@CreationTimestamp` and `@UpdateTimestamp`  are hibernate annotations that automatically populates timestamps exactly
once when an entity is first persisted and updates timestamp with each update respectively.
- `Lombok` annotation processor needs explicit configuration in order for maven to process the annotations.
- `@SuperBuilder` Standard `@Builder` works well for single classes but struggles with inheritance. `@SuperBuilder` extends 
this capability, allowing you to create builder patterns in a hierarchy where subclasses inherit the builder structure 
of their superclass.
- Also learned from the [blog](https://protsenko.dev/spring-data-jpa-best-practices-entity-design-guide/) that `@Data`
annotation might interfere with JPA sometimes. Good to know.

## 07/02/2026

Sat down tonight to finish setting up global exception handlers with custom error responses.
Then I came across something called `ProblemDetail` - [RFC9457](https://datatracker.ietf.org/doc/html/rfc9457) which seems
like a new standard for HTTP error responses. But I was conflicted with this new "ProblemDetail" which has fields like
`type` `detail` `instance` but I'm not sure if this has been adopted as a standard in the web world. 


## 08/02/2026

After contemplating the entire night, decided to go with the `ProblemDetail` based error responses since its supported 
by spring boot out of the box, hence I don't need to write extra code for error response handling.

Wrote complete end to end code for the following endpoints

- `getUserById - GET /matinee/api/v1/users/:id`
- `getUserByUsername - GET /matinee/api/v1/users?username=<username>`
- `addNewUser - POST /matinee/api/v1/users`


Changelog

- Custom Response Entity - MatineeResponse
- Custom Exceptions
  - MatineeBaseException
  - MatineeNotFoundException
- Unit Tests covering Service and Converters
- Added JaCoCo reports for code and test coverage
- Wrote unit tests with 89% coverage.